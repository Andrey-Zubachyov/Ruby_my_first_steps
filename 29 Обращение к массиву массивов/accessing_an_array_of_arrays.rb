
=begin
Обращение к массиву массивов//accessing an array of arrays

Существует небольшая хитрость для обращения к массиву массивов (также говорят “к двумерному массиву”, к “2D array”). Хитрость заключается в том, что сначала нужно обратиться к строке (row), а потом к столбцу (column). Способ обращения к обычному массиву мы уже знаем. Для вывода значения используется следующая конструкция:
=end

puts arr[4]

# Для присваивания мы просто используем оператор `=`:

arr[4] = 123

=begin
Где 4 - это индекс массива. В случае с двумерным массивом обычно используются двойные квадратные скобки. Например, следующий код обновит в 5-ой строке 9-ый столбец:
=end

arr[4][8] = 123

=begin
Такой способ обращения может показаться непривычным для обычного человека, потому что человек привык сначала указывать столбец, потом строку; сначала X, потом Y. Но тем не менее, для доступа к массиву нам нужно сначала указывать индекс строки, а потом
уже индекс столбца. Причем, ничто не мешает записать нам конструкцию присваивания иначе, она будет намного понятнее (правда, длиннее):
=end

row = arr[4]
row[8] = 123

#А вот так можно вывести значение девятого столбца в пятой строке (альтернативный способ):

row = arr[4] # на этом этапе row уже будет одномерный (обычный) массив
column = row[8]
puts column

=begin
В зависимости от типа задачи и от приложения с которым вы работаете, может использоваться разная терминология, обозначающая строку и столбец. Рассмотрим наиболее часто встречающиеся:
? `row` - строка, `column` - столбец. Обращение к массиву: `arr[row][column]`.
? `y` - строка, `x` - столбец. Обращение к массиву: `arr[y][x]`
? `j` - строка, `i` - столбец. Обращение к массиву: `arr[j][i]`
Обратите внимание, что название переменной для индекса - `i` (от слова `index`). Если у нас есть более одной переменной для индекса, берется следующая буква в алфавите (`j`, а если массив трехмерный, то `k`). Впрочем, эти правила не являются каким-то стандартом, а всего-лишь наблюдением авторов.

Попробуем создать двумерный массив и обойти (to traverse) его. Это элементарная задача, которая вам может встретиться на интервью: 2D array traversal:
=end

arr = [
	%w(a b c),
	%w(d e f),
	%w(g h i)
]
0.upto(2) do |j|
	0.upto(2) do |i|
		print arr[j][i]
	end
end

=begin
Вверху мы видим двойной цикл (иногда его называют “вложенный цикл”, “double loop”, если имеют в виду цикл по `i` - то “inner loop”, “внутренний цикл”). Как же он работает? Мы уже знаем, что “цикл j” просто “проходит” по массиву. Он “не знает”, что у нас массив массивов, поэтому это обычная итерация по элементам массива:
=end

%w(a b c)
%w(d e f)
%w(g h i)

=begin
Просто каждый элемент - еще один массив. Поэтому мы имеем право по нему пройти обычным образом, как мы это уже делали. Можно также записать нашу программу немного иначе, помощью “each”:
=end

arr = [
	%w(a b c),
	%w(d e f),
	%w(g h i)
]
arr.each do |row|
	row.each do |value|
		print value
	end
end

=begin
Разумеется, что сам массив можно записать без помощи “%w” (согласитесь, что читаемость этого подхода немного ниже?):
=end

arr = [
	['a', 'b', 'c'],
	['d', 'e', 'f'],
	['g', 'h', 'i']
]

=begin
Задание: обойдите массив выше “вручную”, без помощи циклов, крест-накрест, таким образом, чтобы вывести на экран строку “aeiceg” (подпрограмма займет 6 строк - по 1строке для каждого элемента).
=end

arr = [
	%w(a b c),
	%w(d e f),
	%w(g h i)
]

print arr[0][0]
print arr[1][1]
print arr[2][2]
print arr[0][2]
print arr[1][1]
print arr[1][0]

=begin
Задание: создайте 2D массив размером 3 на 3. Каждый элемент будет иметь одинаковое значение (например, “something”). Сделайте так, чтобы каждый элемент массива был защищен от “upcase!”. Например, если мы вызовем `arr[2][2].upcase!`, этот вызов не изменит содержимое других ячеек массива. Проверьте свое задание в pry.
=end

arr = Array.new(5) {Array.new(3) {'something'}}
arr[2][1].upcase!
p arr


=begin
Задание: к вам обратился предприниматель Джон Смит. Джон говорит, что его бизнес специализируется на создании телефонных номеров для рекламы. Они хотят подписать с вами контракт, но прежде хотелось бы убедиться, что вы хороший программист, можете работать с их требованиями, и доставлять качественное программное обеспечение.
Они говорят: у нас есть номера телефонов с буквами. Например, для бизнеса по продаже матрасов существует номер “555-MATRESS”, который транслируется в “555-628-7377”.
Когда наши клиенты набирают буквенный номер на клавиатуре телефона (см.картинку ниже), он транслируется в цифровой. Напишите программу, которая будет переводить (транслировать) слово без дефисов в телефонный номер.
Сигнатура метода будет следующей:
def phone_to_number(phone)
# ваш код тут...
end
puts phone_to_number('555MATRESS') # должно напечатать 5556287377
=end

# Создаём массив с подмассивом кнопок телефона
arr = [['0'], ['1'], ['5', 'a', 'b', 'c'], ['6', 'd', 'e', 'f'], ['7', 'g', 'h', 'i'], ['8', 'j', 'k', 'l'], ['9', 'm', 'n', 'o'], ['4', 'p', 'q', 'r', 's'], ['3', 't', 'u', 'v'], ['2', 'w', 'x', 'y', 'z']]


# Предлагаем ввести номер телефона с буквами
puts 'ENTER TELEPHONE NUMBER WITH LETTERS: '
num = gets.chomp

# Преобразуем введённый номер пользователем о массив строк
num_phone = num.split('')

# Выводим номер телефона введённый пользователем преобразовывая в строку методом  .join
puts "Your enter: #{num_phone.join}"

# Проходим по массиву num_phone и заменем литеру цифровым обозначением массива arr c 0 индексом
arr2 = []
num_phone.each do |i|
       arr.each_with_index do |x, v|
        if arr[v].include?(i)
             arr2 << arr[v][0]
        end
    end
end

# выводим преобразованный в массив arr2 номер телефона
print "Your number phone: #{arr2.join}"




