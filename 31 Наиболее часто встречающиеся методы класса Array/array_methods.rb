#ћетод empty?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
=begin
«нак вопроса на конце метода означает, что метод будет возвращать значение типа
Boolean (true или false). ћетод Уempty?Ф используетс€ дл€ того, чтобы убедитьс€ в том,что массив не пустой (или пустой). ≈сли массив пустой (empty), то Уempty?Ф возвращает
УtrueФ:
=end

[].empty?
=> true

=begin
¬ажный момент заключаетс€ в том, что объект УnilФ не реализует метод Уempty?Ф. “.е. если вы не уверены, что какой-то метод возвращает массив, необходимо сделать проверку на nil:
=end

arr = some_method
if !arr.nil? && !arr.empty?
puts arr.inspect
end

=begin
—уществует одна важна€ деталь. “.к. любой руби-программист почти со 100% веро€тностью будет работать с rails, нужно знать, что проверка коллекции (в т.ч.массива)в rails выполн€етс€ иначе. “.е. если вы оставите этот синтаксис, то ошибки не будет,просто есть более эффективный способ:
=end

if !arr.blank?
puts arr.inspect
end

#»ли использу€ пр€мо противоположный метод Уpresent?Ф:

if arr.present?
puts arr.inspect
end

#»ли использу€ пр€мо противоположный метод Уpresent?Ф:

if arr.present?
puts arr.inspect
end
#метод Уempty?Ф реализован дл€ типов String, Array, Hash.
============================================================================================

#ћетоды length, size, count!!!!!!!!!!!!!!!!!!!!!!
=begin
ћетоды length и size идентичны и реализованы дл€ классов Array, String, Hash:
=end

[11, 22, 33].size # => 3
[11, 22, 33].length # => 3

str = 'something'
str.size # => 9
str.length # => 9

hh = { a: 1, b: 2 }
hh.size # => 2
hh.length # => 2

=begin
ћетод count выполн€ет ту же функцию, что и length/size, но только дл€ классов Array и Hash (не реализован в String). ќднако, метод count может принимать блок, можно использовать его дл€ каких-либо вычислений. Ќапример, посчитать количество нулей в массиве:
=end

[0, 0, 1, 1, 0, 0, 1, 0].count { |x| x == 0 } #=> 5

=begin
”добно использовать метод count вместе с указателем на функцию. ≈сли метод Уzero?Ф реализован у всех элементов массива, можно записать конструкцию выше иначе:
=end

[0, 0, 1, 1, 0, 0, 1, 0].count(&:zero?)

=begin
«адание: с помощью указател€ на функцию посчитайте количество четных элементов в массиве [11, 22, 33, 44, 55].
=end

arr = [11, 22, 33, 44, 55]

# первый пример через блок функции count
puts arr.count {|x| x % 2 == 0}

#второй пример через указание на функцию count методом &:even?
puts arr.count(&:even?)

=============================================================================================
ћетод include?!!!!!!!!!!!!!!!!!!!!!!!!!!!

=begin
ћетод Уinclude?Ф провер€ет массив на наличие определенного элемента и возвращает
значение типа Boolean. Ќапример:
=end

puts [1, 2, 3, 5, 8].include?(3) #=>true

================================================================================================

ƒобавление элементов!!!!!!!!!!!!!!!!!!!!!!!!!!

=begin
ƒобавление элементов в массив реализовано с помощью уже знакомых нам методов
УpushФ и УpopФ. Ёти методы производ€т операции с хвостом массива: добавить элемент в
конец, извлечь последний.   слову, массив в руби реализует также структуру данных
УстекФ. ѕредставьте себе УстекФ тарелок, когда одна тарелка стоит на другой. ћы кладем
одну наверх и берем также сверху.
Ќо есть операции УunshiftФ и УshiftФ, которые делают то же самое, что и УpushФ, УpopФ, но
только с началом массива. Ќередко у программистов возникает путаница при
использовании unshift и shift, но важно помнить (или уметь посмотреть в документации)
следующее:
? unshift почти то же самое, что и push
? shift почти то же самое, что и pop
ѕолезна€ метафора тут может быть така€: shift сдвигает элементы и возвращает тот
элемент, которому не досталось места.
end

===============================================================================================

¬ыбор элементов по критерию (select)!!!!!!!!!!!!!!!!!!!!!!!!

arr = [ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ]

arr.select { |element| element[0] == 64 && element[1] == 1 }
(выбран 1 элемент)




ќтсечение элементов по критерию (reject)!!!!!!!!!!!!!!!!!!!

=begin
ћетод УrejectФ класса Array работает аналогично УselectФ, но отсеивает элементы,
удовлетвор€ющие критерию.
=end

arr = [ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ]
arr.reject { |element| element[0] >= 30 }
(выбран 1 элемент двадцати п€ти лет, который скоро пойдет в армию)


ћетод take!!!!!!!!!!!!!!!!!!!!!!!

=begin
ћетод УtakeФ принимает параметр (число) и берет определенное количество элементов в
начале массива:
=end

[11, 22, 33, 44, 55].take(2) #=> [11, 22]


≈сть ли хот€ бы одно совпадение (any?)!!!!!!!!!!!!!!!!!!!

[false, false, false, true, false].any? { |element| element == true } #=> true

=begin
 од выше показывает что среди 5 билетов есть 1 выигрыш. Ётот метод только сообщает
о том, что выигрыш имеетс€, он не говорит, какой именно билет выиграл. “.е. метод не
возвращает индекс. „тобы найти индекс (какой билет выиграл), принцип наименьшего
сюрприза подсказывает, что должен быть метод Уfind_indexФ. ѕроверим:
=end

[false, false, false, true, false].find_index { |element| element == true } #=> 3


¬се элементы должны удовлетвор€ть критерию (all?)!!!!!!!!!!!!!!

=begin
ƒопустим, у нас массив возрастов пользователей, нам нужно убедитьс€, что все
пользователи взрослые (18 лет или более).  ак это сделать? ќчень просто с помощью
метода Уall?Ф:
=end


[20, 34, 65, 23, 18, 44, 32].all? { |element| element >= 18 } #=> true